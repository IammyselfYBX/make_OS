;主引导程序
;该程序是使用BIOS中断实现
;------------------------------------------------------------
SECTION MBR vstart=0x7c00   ;告诉编译器，把我的起始地址编译为 Ox7c00      
   mov ax,cs      ;因为BIOS是通过 jmp 0:0x7c00 所以此时 cs=0,
   mov ds,ax      ;接下来的就是使用cs来初始化其他寄存器
   mov es,ax      ;对于 ds,es,fs,gs这些段寄存器是不能使用 mov 赋初值，所以采用 cs 来赋初值
   mov ss,ax
   mov fs,ax
   mov ax,0xb800
   mov gs,ax
   mov ax,cs
   mov sp,0x7c00

; 清屏利用0x06号功能，上卷全部行，则可清屏
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述：上卷窗口
;------------------------------------------------------
;输入：
;AH 功能号= 0x06
;AL = 上卷行数(如果为0， 表示全部)
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值
   mov     ax, 0x600
   mov     bx, 0x700
   mov     cx, 0           ; 左上角: (0, 0)
   mov     dx, 0x184f	   ; 右下角: (80,25),即(0x4f,0x18)
			   ; VGA文本模式中，一行只能容纳80个字符，共25行。
			   ; 下标从0开始,所以 0x18=24,0x4f=79
   int     0x10            ; int 0x10

;;;;;;;;;    下面3行代码获取光标位置    ;;;;;;;;;
;.get_cursor获取当前光标位置，在光标位置处打印字符
   mov ah, 3		; 输入: 3号子功能是获取光标位置，需要存入 ah 寄存器
   mov bh, 0		; bh寄存器存储的是待获取光标的页号
                  ;显示器有很多种模式，如图形模式、文本模式等。 在文本模式中，又可以工作于 80*25 40*25 等显示方式，默认情况下，所有个人计算机上的显卡在加电后都将自己置为 80*25 这种显示方式 。 80*25 是指一屏可以显 25 行、每行 80 列的字符，也就是 2000 个字符。但由于 一个字符要用两字节来表示，低字符是字符的 ASCII 编码， 高字节是字符属性，故显示一屏字符需要用 4000 字节（实际上，分配给一屏的容量是 4KB），这一屏就称为一页， 0页是默认页
   int 0x10		; 输出：ch=光标开始行，cl=光标结束行
			      ; dh=光标所在行，dl=光标所在列

;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;
   mov byte [gs:0x00],'I'
   mov byte [gs:0x01],0xA4     ; A 表示绿色背景闪烁，C表示前景色为红色并且高亮 AC表示1010 1100

   mov byte [gs:0x02],'n'
   mov byte [gs:0x03],0xA4

   mov byte [gs:0x04],' '
   mov byte [gs:0x05],0xA4

   mov byte [gs:0x06],'M'
   mov byte [gs:0x07],0xAC    ;; A 表示绿色背景闪烁，4 表示前景色为红色

   mov byte [gs:0x08],'B'
   mov byte [gs:0x09],0xAC

   mov byte [gs:0x0a],'R'
   mov byte [gs:0x0b],0xAC
;;;;;;;;;     打印字符串    ;;;;;;;;;;;
; 打印字符串利用0x13号功能
; -----------------------------------------------------------
;INT 0x10   功能号:0x13	   功能描述：打印字符串
;------------------------------------------------------
;输入：
;AH 功能号= 0x13
;AL 表示写字符串方式
;  (1) al=O ，显示字符串，并且光标返回起始位置。
;  (2) al=l ，显示字符串，并且光标跟随到新位置。
;  (3) al=2 ，显示 符串及其属性，并且光标返回起始位置
;  (4) al=3 ，显示 符串及其属性，光标跟随到新位置。
;
;CX 存放串长度(不包括结束符 0 的字符个数)
;BH 存储要显示的页号
;BL 存储字符属性
;无返回值

;还是用10h中断，不过这次调用13号子功能打印字符串
   mov ax, message 
   mov bp, ax		; es:bp 为串首地址，es此时同cs一致，
			         ; 开头时已经为 sreg 初始化

   ; 光标位置要用 dx 寄存器中内容， ex 中的光标位置可忽略
   mov cx, 38		; cx 为串长度，不包括结束符 0 的字符个数
   mov ax, 0x1301	; 子功能号 13 显示字符及属性，要存入 ah 寄存器，
			         ; al 设置写字符方式 ah=Ol ：显示字符串，光标跟随移动
   mov bx, 0x2		; bh 存储要显示的页号，此处是第 0 页,
			         ; bl 中是字符属性，属性黑底绿字（bl = 02h) 
   int 0x10		   ; ִ执行 BIOS OxlO 号中断
;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

   jmp $		      ; 使程序悬停在此

   message db "YBX is the most handsome man in NCEPU"
   times 510-($-$$) db 0   ;这512个字节最后两个是 0x55,0xaa,其余都要有 0 填满， $-$$表示本行到本section的偏移量
   db 0x55,0xaa
